(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{337:function(_,v,t){"use strict";t.r(v);var n=t(18),p=Object(n.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("wangdoc.com /bash/expansion.html\nBash 的模式扩展\n8-10 minutes\n网道（WangDoc.com），互联网文档计划")]),_._v(" "),t("p",[_._v("简介 #\nShell 接收到用户输入的命令以后，会根据空格将用户的输入，拆分成一个个词元（token）。然后，Shell 会扩展词元里面的特殊字符，扩展完成后才会调用相应的命令。")]),_._v(" "),t("p",[_._v("这种特殊字符的扩展，称为模式扩展（globbing）。其中有些用到通配符，又称为通配符扩展（wildcard expansion）。Bash 一共提供八种扩展。")]),_._v(" "),t("p",[_._v("波浪线扩展\n? 字符扩展")]),_._v(" "),t("ul",[t("li",[_._v("字符扩展\n方括号扩展\n大括号扩展\n变量扩展\n子命令扩展\n算术扩展\n本章介绍这八种扩展。")])]),_._v(" "),t("p",[_._v("Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。这一点务必需要记住。")]),_._v(" "),t("p",[_._v("globbing这个词，来自于早期的 Unix 系统有一个/etc/glob文件，保存扩展的模板。后来 Bash 内置了这个功能，但是这个名字就保留了下来。")]),_._v(" "),t("p",[_._v("模式扩展与正则表达式的关系是，模式扩展早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。")]),_._v(" "),t("p",[_._v("Bash 允许用户关闭扩展。")]),_._v(" "),t("p",[_._v("$ set -o noglob")]),_._v(" "),t("p",[_._v("$ set -f\n下面的命令可以重新打开扩展。")]),_._v(" "),t("p",[_._v("$ set +o noglob")]),_._v(" "),t("p",[_._v("$ set +f\n波浪线扩展 #\n波浪线~会自动扩展成当前用户的主目录。")]),_._v(" "),t("p",[_._v("$ echo ~\n/home/me\n~/dir表示扩展成主目录的某个子目录，dir是主目录里面的一个子目录名。")]),_._v(" "),t("p",[_._v("$ cd ~/foo\n~user表示扩展成用户user的主目录。")]),_._v(" "),t("p",[_._v("$ echo ~foo\n/home/foo")]),_._v(" "),t("p",[_._v("$ echo ~root\n/root\n上面例子中，Bash 会根据波浪号后面的用户名，返回该用户的主目录。")]),_._v(" "),t("p",[_._v("如果~user的user是不存在的用户名，则波浪号扩展不起作用。")]),_._v(" "),t("p",[_._v("$ echo ~nonExistedUser\n~nonExistedUser\n~+会扩展成当前所在的目录，等同于pwd命令。")]),_._v(" "),t("p",[_._v("$ cd ~/foo\n$ echo ~+\n/home/me/foo\n? 字符扩展 #\n?字符代表文件路径里面的任意单个字符，不包括空字符。比如，Data???匹配所有Data后面跟着三个字符的文件名。")]),_._v(" "),t("p",[_._v("$ ls ?.txt\na.txt b.txt\n上面命令中，?表示单个字符，所以会同时匹配a.txt和b.txt。")]),_._v(" "),t("p",[_._v("如果匹配多个字符，就需要多个?连用。")]),_._v(" "),t("p",[_._v("$ ls ??.txt\nab.txt\n上面命令中，??匹配了两个字符。")]),_._v(" "),t("p",[_._v("? 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。")]),_._v(" "),t("p",[_._v("$ echo ?.txt\na.txt")]),_._v(" "),t("p",[_._v("$ echo ?.txt\n?.txt\n上面例子中，如果?.txt可以扩展成文件名，echo命令会输出扩展后的结果；如果不能扩展成文件名，echo就会原样输出?.txt。")]),_._v(" "),t("ul",[t("li",[_._v("字符扩展 #\n*字符代表文件路径里面的任意数量的字符，包括零个字符。")])]),_._v(" "),t("p",[_._v("$ ls *.txt\na.txt b.txt ab.txt")]),_._v(" "),t("p",[_._v("$ ls *\n下面是*匹配空字符的例子。")]),_._v(" "),t("p",[_._v("$ ls a*.txt\na.txt ab.txt")]),_._v(" "),t("p",[_._v("$ ls "),t("em",[_._v("b")]),_._v("\nb.txt ab.txt\n注意，*不会匹配隐藏文件（以.开头的文件）。")]),_._v(" "),t("p",[_._v("$ echo .*")]),_._v(" "),t("p",[_._v("$ echo .[!.]*\n*字符扩展也属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。")]),_._v(" "),t("p",[_._v("$ echo c*.txt\nc*.txt\n上面例子中，当前目录里面没有c开头的文件，导致c*.txt会原样输出。")]),_._v(" "),t("p",[_._v("*只匹配当前目录，不会匹配子目录。")]),_._v(" "),t("p",[_._v("$ ls *.txt")]),_._v(" "),t("p",[_._v("$ ls "),t("em",[_._v("/")]),_._v(".txt\n上面的例子，文本文件在子目录，"),t("em",[_._v(".txt不会产生匹配，必须写成")]),_._v("/*.txt。有几层子目录，就必须写几层星号。")]),_._v(" "),t("p",[_._v("Bash 4.0 引入了一个参数globstar，当该参数打开时，允许"),t("strong",[_._v("匹配零个或多个子目录。因此，")]),_._v("/*.txt可以匹配顶层的文本文件和任意深度子目录的文本文件。详细介绍请看后面shopt命令的介绍。")]),_._v(" "),t("p",[_._v("方括号扩展 #\n方括号扩展的形式是[...]，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。比如，[aeiou]可以匹配五个元音字母中的任意一个。")]),_._v(" "),t("p",[_._v("$ ls [ab].txt\na.txt b.txt")]),_._v(" "),t("p",[_._v("$ ls [ab].txt\na.txt\n上面例子中，[ab]可以匹配a或b，前提是确实存在相应的文件。")]),_._v(" "),t("p",[_._v("方括号扩展属于文件名匹配，即扩展后的结果必须符合现有的文件路径。如果不存在匹配，就会保持原样，不进行扩展。")]),_._v(" "),t("p",[_._v("$ ls [ab].txt\nls: 无法访问'[ab].txt': 没有那个文件或目录\n上面例子中，由于扩展后的文件不存在，[ab].txt就原样输出了，导致ls命名报错。")]),_._v(" "),t("p",[_._v("方括号扩展还有两种变体：[^...]和[!...]。它们表示匹配不在方括号里面的字符，这两种写法是等价的。比如，[^abc]或[!abc]表示匹配除了a、b、c以外的字符。")]),_._v(" "),t("p",[_._v("$ ls ?[!a]?\naba bbb\n上面命令中，[!a]表示文件名第二个字符不是a的文件名，所以返回了aba和bbb两个文件。")]),_._v(" "),t("p",[_._v("注意，如果需要匹配[字符，可以放在方括号内，比如[[aeiou]。如果需要匹配连字号-，只能放在方括号内部的开头或结尾，比如[-aeiou]或[aeiou-]。")]),_._v(" "),t("p",[_._v("[start-end] 扩展 #\n方括号扩展有一个简写形式[start-end]，表示匹配一个连续的范围。比如，[a-c]等同于[abc]，[0-9]匹配[0123456789]。")]),_._v(" "),t("p",[_._v("$ ls [a-c].txt\na.txt\nb.txt\nc.txt")]),_._v(" "),t("p",[_._v("$ ls report[0-9].txt\nreport1.txt\nreport2.txt\nreport3.txt\n...\n下面是一些常用简写的例子。")]),_._v(" "),t("p",[_._v("[a-z]：所有小写字母。\n[a-zA-Z]：所有小写字母与大写字母。\n[a-zA-Z0-9]：所有小写字母、大写字母与数字。\n[abc]*：所有以a、b、c字符之一开头的文件名。\nprogram.[co]：文件program.c与文件program.o。\nBACKUP.[0-9][0-9][0-9]：所有以BACKUP.开头，后面是三个数字的文件名。\n这种简写形式有一个否定形式[!start-end]，表示匹配不属于这个范围的字符。比如，[!a-zA-Z]表示匹配非英文字母的字符。")]),_._v(" "),t("p",[_._v("$ echo report[!1–3].txt\nreport4.txt report5.txt\n上面代码中，[!1-3]表示排除1、2和3。")]),_._v(" "),t("p",[_._v("大括号扩展 #\n大括号扩展{...}表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，{1,2,3}扩展成1 2 3。")]),_._v(" "),t("p",[_._v("$ echo {1,2,3}\n1 2 3")]),_._v(" "),t("p",[_._v("$ echo d{a,e,i,u,o}g\ndag deg dig dug dog")]),_._v(" "),t("p",[_._v("$ echo Front-{A,B,C}-Back\nFront-A-Back Front-B-Back Front-C-Back\n注意，大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。")]),_._v(" "),t("p",[_._v("$ ls {a,b,c}.txt\nls: 无法访问'a.txt': 没有那个文件或目录\nls: 无法访问'b.txt': 没有那个文件或目录\nls: 无法访问'c.txt': 没有那个文件或目录\n上面例子中，即使不存在对应的文件，{a,b,c}依然扩展成三个文件名，导致ls命令报了三个错误。")]),_._v(" "),t("p",[_._v("另一个需要注意的地方是，大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。")]),_._v(" "),t("p",[_._v("$ echo {1 , 2}\n{1 , 2}\n上面例子中，逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。")]),_._v(" "),t("p",[_._v("逗号前面可以没有值，表示扩展的第一项为空。")]),_._v(" "),t("p",[_._v("$ cp a.log{,.bak}")]),_._v(" "),t("p",[_._v("大括号可以嵌套。")]),_._v(" "),t("p",[_._v("$ echo {j{p,pe}g,png}\njpg jpeg png")]),_._v(" "),t("p",[_._v("$ echo a{A{1,2},B{3,4}}b\naA1b aA2b aB3b aB4b\n大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。")]),_._v(" "),t("p",[_._v("$ echo {cat,d*}\ncat dawg dg dig dog doug dug\n上面例子中，会先进行大括号扩展，然后进行*扩展。")]),_._v(" "),t("p",[_._v("大括号可以用于多字符的模式，方括号不行（只能匹配单字符）。")]),_._v(" "),t("p",[_._v("$ echo {cat,dog}\ncat dog\n由于大括号扩展{...}不是文件名扩展，所以它总是会扩展的。这与方括号扩展[...]完全不同，如果匹配的文件不存在，方括号就不会扩展。这一点要注意区分。")]),_._v(" "),t("p",[_._v("$ echo [ab].txt\n[ab].txt")]),_._v(" "),t("p",[_._v("$ echo {a,b}.txt\na.txt b.txt\n上面例子中，如果不存在a.txt和b.txt，那么[ab].txt就会变成一个普通的文件名，而{a,b}.txt可以照样扩展。")]),_._v(" "),t("p",[_._v("{start..end} 扩展 #\n大括号扩展有一个简写形式{start..end}，表示扩展成一个连续序列。比如，{a..z}可以扩展成26个小写英文字母。")]),_._v(" "),t("p",[_._v("$ echo {a..c}\na b c")]),_._v(" "),t("p",[_._v("$ echo d{a..d}g\ndag dbg dcg ddg")]),_._v(" "),t("p",[_._v("$ echo {1..4}\n1 2 3 4")]),_._v(" "),t("p",[_._v("$ echo Number_{1..5}\nNumber_1 Number_2 Number_3 Number_4 Number_5\n这种简写形式支持逆序。")]),_._v(" "),t("p",[_._v("$ echo {c..a}\nc b a")]),_._v(" "),t("p",[_._v("$ echo {5..1}\n5 4 3 2 1\n注意，如果遇到无法理解的简写，大括号模式就会原样输出，不会扩展。")]),_._v(" "),t("p",[_._v("$ echo {a1..3c}\n{a1..3c}\n这种简写形式可以嵌套使用，形成复杂的扩展。")]),_._v(" "),t("p",[_._v("$ echo .{mp{3..4},m4{a,b,p,v}}\n.mp3 .mp4 .m4a .m4b .m4p .m4v\n大括号扩展的常见用途为新建一系列目录。")]),_._v(" "),t("p",[_._v("$ mkdir {2007..2009}-{01..12}\n上面命令会新建36个子目录，每个子目录的名字都是”年份-月份“。")]),_._v(" "),t("p",[_._v("这个写法的另一个常见用途，是直接用于for循环。")]),_._v(" "),t("p",[_._v("for i in {1..4}\ndo\necho $i\ndone\n上面例子会循环4次。")]),_._v(" "),t("p",[_._v("如果整数前面有前导0，扩展输出的每一项都有前导0。")]),_._v(" "),t("p",[_._v("$ echo {01..5}\n01 02 03 04 05")]),_._v(" "),t("p",[_._v("$ echo {001..5}\n001 002 003 004 005\n这种简写形式还可以使用第二个双点号（start..end..step），用来指定扩展的步长。")]),_._v(" "),t("p",[_._v("$ echo {0..8..2}\n0 2 4 6 8\n上面代码将0扩展到8，每次递增的长度为2，所以一共输出5个数字。")]),_._v(" "),t("p",[_._v("多个简写形式连用，会有循环处理的效果。")]),_._v(" "),t("p",[_._v("$ echo {a..c}{1..3}\na1 a2 a3 b1 b2 b3 c1 c2 c3\n变量扩展 #\nBash 将美元符号$开头的词元视为变量，将其扩展成变量值，详见《Bash 变量》一章。")]),_._v(" "),t("p",[_._v("$ echo $SHELL\n/bin/bash\n变量名除了放在美元符号后面，也可以放在${}里面。")]),_._v(" "),t("p",[_._v("$ echo ${SHELL}\n/bin/bash\n${!string*}或${!string@}返回所有匹配给定字符串string的变量名。")]),_._v(" "),t("p",[_._v("$ echo ${!S*}\nSECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK\n上面例子中，${!S*}扩展成所有以S开头的变量名。")]),_._v(" "),t("p",[_._v("子命令扩展 #\n$(...)可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值。")]),_._v(" "),t("p",[_._v("$ echo $(date)\nTue Jan 28 00:01:13 CST 2020\n上面例子中，$(date)返回date命令的运行结果。")]),_._v(" "),t("p",[_._v("还有另一种较老的语法，子命令放在反引号之中，也可以扩展成命令的运行结果。")]),_._v(" "),t("p",[_._v("$ echo "),t("code",[_._v("date")]),_._v("\nTue Jan 28 00:01:13 CST 2020\n$(...)可以嵌套，比如$(ls $(pwd))。")]),_._v(" "),t("p",[_._v("算术扩展 #\n$((...))可以扩展成整数运算的结果，详见《Bash 的算术运算》一章。")]),_._v(" "),t("p",[_._v("$ echo $((2 + 2))\n4\n字符类 #\n[[:class:]]表示一个字符类，扩展成某一类特定字符之中的一个。常用的字符类如下。")]),_._v(" "),t("p",[_._v("[[:alnum:]]：匹配任意英文字母与数字\n[[:alpha:]]：匹配任意英文字母\n[[:blank:]]：空格和 Tab 键。\n[[:cntrl:]]：ASCII 码 0-31 的不可打印字符。\n[[:digit:]]：匹配任意数字 0-9。\n[[:graph:]]：A-Z、a-z、0-9 和标点符号。\n[[:lower:]]：匹配任意小写字母 a-z。\n[[:print:]]：ASCII 码 32-127 的可打印字符。\n[[:punct:]]：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。\n[[:space:]]：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。\n[[:upper:]]：匹配任意大写字母 A-Z。\n[[:xdigit:]]：16进制字符（A-F、a-f、0-9）。\n请看下面的例子。")]),_._v(" "),t("p",[_._v("$ echo [[:upper:]]*\n上面命令输出所有大写字母开头的文件名。")]),_._v(" "),t("p",[_._v("字符类的第一个方括号后面，可以加上感叹号!，表示否定。比如，[![:digit:]]匹配所有非数字。")]),_._v(" "),t("p",[_._v("$ echo [![:digit:]]*\n上面命令输出所有不以数字开头的文件名。")]),_._v(" "),t("p",[_._v("字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。")]),_._v(" "),t("p",[_._v("$ echo [[:upper:]]*\n[[:upper:]]*\n上面例子中，由于没有可匹配的文件，字符类就原样输出了。")]),_._v(" "),t("p",[_._v("使用注意点 #\n通配符有一些使用注意点，不可不知。")]),_._v(" "),t("p",[_._v("（1）通配符是先解释，再执行。")]),_._v(" "),t("p",[_._v("Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。")]),_._v(" "),t("p",[_._v("$ ls a*.txt\nab.txt\n上面命令的执行过程是，Bash 先将a*.txt扩展成ab.txt，然后再执行ls ab.txt。")]),_._v(" "),t("p",[_._v("（2）文件名扩展在不匹配时，会原样输出。")]),_._v(" "),t("p",[_._v("文件名扩展在没有可匹配的文件时，会原样输出。")]),_._v(" "),t("p",[_._v("$ echo r*\nr*\n上面代码中，由于不存在r开头的文件名，r*会原样输出。")]),_._v(" "),t("p",[_._v("下面是另一个例子。")]),_._v(" "),t("p",[_._v("$ ls *.csv\nls: *.csv: No such file or directory\n另外，前面已经说过，大括号扩展{...}不是文件名扩展。")]),_._v(" "),t("p",[_._v("（3）只适用于单层路径。")]),_._v(" "),t("p",[_._v("所有文件名扩展只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。")]),_._v(" "),t("p",[_._v("如果要匹配子目录里面的文件，可以写成下面这样。")]),_._v(" "),t("p",[_._v("$ ls "),t("em",[_._v("/")]),_._v(".txt\nBash 4.0 新增了一个globstar参数，允许**匹配零个或多个子目录，详见后面shopt命令的介绍。")]),_._v(" "),t("p",[_._v("（4）文件名可以使用通配符。")]),_._v(" "),t("p",[_._v("Bash 允许文件名使用通配符，即文件名包括特殊字符。这时引用文件名，需要把文件名放在单引号里面。")]),_._v(" "),t("p",[_._v("$ touch 'fo*'\n$ ls\nfo*\n上面代码创建了一个fo"),t("em",[_._v("文件，这时")]),_._v("就是文件名的一部分。")]),_._v(" "),t("p",[_._v("量词语法 #\n量词语法用来控制模式匹配的次数。它只有在 Bash 的extglob参数打开的情况下才能使用，不过一般是默认打开的。下面的命令可以查询。")]),_._v(" "),t("p",[_._v("$ shopt extglob\nextglob         on\n量词语法有下面几个。")]),_._v(" "),t("p",[_._v("?(pattern-list)：匹配零个或一个模式。\n*(pattern-list)：匹配零个或多个模式。\n+(pattern-list)：匹配一个或多个模式。\n@(pattern-list)：只匹配一个模式。\n!(pattern-list)：匹配零个或一个以上的模式，但不匹配单独一个的模式。\n$ ls abc?(.)txt\nabctxt abc.txt\n上面例子中，?(.)匹配零个或一个点。")]),_._v(" "),t("p",[_._v("$ ls abc?(def)\nabc abcdef\n上面例子中，?(def)匹配零个或一个def。")]),_._v(" "),t("p",[_._v("$ ls abc+(.txt|.php)\nabc.php abc.txt\n上面例子中，+(.txt|.php)匹配文件有一个.txt或.php后缀名。")]),_._v(" "),t("p",[_._v("$ ls abc+(.txt)\nabc.txt abc.txt.txt\n上面例子中，+(.txt)匹配文件有一个或多个.txt后缀名。")]),_._v(" "),t("p",[_._v("量词语法也属于文件名扩展，如果不存在可匹配的文件，就会原样输出。")]),_._v(" "),t("p",[_._v("$ ls abc?(def)\nls: 无法访问'abc?(def)': 没有那个文件或目录\n上面例子中，由于没有可匹配的文件，abc?(def)就原样输出，导致ls命令报错。")]),_._v(" "),t("p",[_._v("shopt 命令 #\nshopt命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。")]),_._v(" "),t("p",[_._v("shopt命令的使用方法如下。")]),_._v(" "),t("p",[_._v("$ shopt -s [optionname]")]),_._v(" "),t("p",[_._v("$ shopt -u [optionname]")]),_._v(" "),t("p",[_._v("$ shopt [optionname]\n（1）dotglob 参数")]),_._v(" "),t("p",[_._v("dotglob参数可以让扩展结果包括隐藏文件（即点开头的文件）。")]),_._v(" "),t("p",[_._v("正常情况下，扩展结果不包括隐藏文件。")]),_._v(" "),t("p",[_._v("$ ls *\nabc.txt\n打开dotglob，就会包括隐藏文件。")]),_._v(" "),t("p",[_._v("$ shopt -s dotglob\n$ ls *\nabc.txt .config\n（2）nullglob 参数")]),_._v(" "),t("p",[_._v("nullglob参数可以让通配符不匹配任何文件名时，返回空字符。")]),_._v(" "),t("p",[_._v("默认情况下，通配符不匹配任何文件名时，会保持不变。")]),_._v(" "),t("p",[_._v("$ rm b*\nrm: 无法删除'b*': 没有那个文件或目录\n上面例子中，由于当前目录不包括b开头的文件名，导致b"),t("em",[_._v("不会发生文件名扩展，保持原样不变，所以rm命令报错没有b")]),_._v("这个文件。")]),_._v(" "),t("p",[_._v("打开nullglob参数，就可以让不匹配的通配符返回空字符串。")]),_._v(" "),t("p",[_._v("$ shopt -s nullglob\n$ rm b*\nrm: 缺少操作数\n上面例子中，由于没有b"),t("em",[_._v("匹配的文件名，所以rm b")]),_._v("扩展成了rm，导致报错变成了”缺少操作数“。")]),_._v(" "),t("p",[_._v("（3）failglob 参数")]),_._v(" "),t("p",[_._v("failglob参数使得通配符不匹配任何文件名时，Bash 会直接报错，而不是让各个命令去处理。")]),_._v(" "),t("p",[_._v("$ shopt -s failglob\n$ rm b*\nbash: 无匹配: b*\n上面例子中，打开failglob以后，由于b*不匹配任何文件名，Bash 直接报错了，不再让rm命令去处理。")]),_._v(" "),t("p",[_._v("（4）extglob 参数")]),_._v(" "),t("p",[_._v("extglob参数使得 Bash 支持 ksh 的一些扩展语法。它默认应该是打开的。")]),_._v(" "),t("p",[_._v("$ shopt extglob\nextglob         on\n它的主要应用是支持量词语法。如果不希望支持量词语法，可以用下面的命令关闭。")]),_._v(" "),t("p",[_._v("$ shopt -u extglob\n（5）nocaseglob 参数")]),_._v(" "),t("p",[_._v("nocaseglob参数可以让通配符扩展不区分大小写。")]),_._v(" "),t("p",[_._v("$ shopt -s nocaseglob\n$ ls /windows/program*\n/windows/ProgramData\n/windows/Program Files\n/windows/Program Files (x86)\n上面例子中，打开nocaseglob以后，program*就不区分大小写了，可以匹配ProgramData等。")]),_._v(" "),t("p",[_._v("（6）globstar 参数")]),_._v(" "),t("p",[_._v("globstar参数可以使得**匹配零个或多个子目录。该参数默认是关闭的。")]),_._v(" "),t("p",[_._v("假设有下面的文件结构。")]),_._v(" "),t("p",[_._v("a.txt\nsub1/b.txt\nsub1/sub2/c.txt\n上面的文件结构中，顶层目录、第一级子目录sub1、第二级子目录sub1\\sub2里面各有一个文本文件。请问怎样才能使用通配符，将它们显示出来？")]),_._v(" "),t("p",[_._v("默认情况下，只能写成下面这样。")]),_._v(" "),t("p",[_._v("$ ls "),t("em",[_._v(".txt "),t("em",[_._v("/")]),_._v(".txt "),t("em",[_._v("/")]),_._v("/")]),_._v(".txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n这是因为*只匹配当前目录，如果要匹配子目录，只能一层层写出来。")]),_._v(" "),t("p",[_._v("打开globstar参数以后，"),t("strong",[_._v("匹配零个或多个子目录。因此，")]),_._v("/*.txt就可以得到想要的结果。")]),_._v(" "),t("p",[_._v("$ shopt -s globstar\n$ ls **/*.txt\na.txt  sub1/b.txt  sub1/sub2/c.txt\n参考链接 #\nThink You Understand Wildcards? Think Again\nAdvanced Wildcard Patterns Most People Don’t Know")])])}),[],!1,null,null,null);v.default=p.exports}}]);